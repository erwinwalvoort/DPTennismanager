{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { IonicNativePlugin, cordova } from '@ionic-native/core';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\n\nvar FCM =\n/** @class */\nfunction (_super) {\n  __extends(FCM, _super);\n\n  function FCM() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FCM.prototype.getAPNSToken = function () {\n    return cordova(this, \"getAPNSToken\", {}, arguments);\n  };\n\n  FCM.prototype.getToken = function () {\n    return cordova(this, \"getToken\", {}, arguments);\n  };\n\n  FCM.prototype.onTokenRefresh = function () {\n    return cordova(this, \"onTokenRefresh\", {\n      \"observable\": true\n    }, arguments);\n  };\n\n  FCM.prototype.subscribeToTopic = function (topic) {\n    return cordova(this, \"subscribeToTopic\", {}, arguments);\n  };\n\n  FCM.prototype.unsubscribeFromTopic = function (topic) {\n    return cordova(this, \"unsubscribeFromTopic\", {}, arguments);\n  };\n\n  FCM.prototype.hasPermission = function () {\n    return cordova(this, \"hasPermission\", {}, arguments);\n  };\n\n  FCM.prototype.onNotification = function () {\n    return cordova(this, \"onNotification\", {\n      \"observable\": true,\n      \"successIndex\": 0,\n      \"errorIndex\": 2\n    }, arguments);\n  };\n\n  FCM.prototype.clearAllNotifications = function () {\n    return cordova(this, \"clearAllNotifications\", {}, arguments);\n  };\n\n  FCM.prototype.requestPushPermissionIOS = function (options) {\n    return cordova(this, \"requestPushPermissionIOS\", {}, arguments);\n  };\n\n  FCM.prototype.createNotificationChannelAndroid = function (channelConfig) {\n    return cordova(this, \"createNotificationChannelAndroid\", {}, arguments);\n  };\n\n  FCM.pluginName = \"FCM\";\n  FCM.plugin = \"cordova-plugin-fcm-with-dependecy-updated\";\n  FCM.pluginRef = \"FCMPlugin\";\n  FCM.repo = \"https://github.com/andrehtissot/cordova-plugin-fcm-with-dependecy-updated\";\n  FCM.platforms = [\"Android\", \"iOS\"];\n\n  FCM.ɵfac = function FCM_Factory(t) {\n    return ɵFCM_BaseFactory(t || FCM);\n  };\n\n  FCM.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: FCM,\n    factory: function factory(t) {\n      return FCM.ɵfac(t);\n    }\n  });\n  var ɵFCM_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(FCM);\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(FCM, [{\n      type: Injectable\n    }], null, null);\n  })();\n\n  return FCM;\n}(IonicNativePlugin);\n\nexport { FCM };","map":{"version":3,"sources":["../../../../../src/@ionic-native/plugins/fcm/ngx/index.ts"],"names":[],"mappings":";AAAA,SAAO,iBAAP,EAAO,OAAP,QAAmD,oBAAnD;AACA,SAAS,UAAT,QAA2B,eAA3B;AACA,SAAS,UAAT,QAA2B,MAA3B;;;AACA,IAAA,GAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AA6HyB,EAAA,SAAA,CAAA,GAAA,EAAA,MAAA,CAAA;;AAAkB,WAAA,GAAA,GAAA;AAE9B,WAAA,MAAA,KAAA,IAAA,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,IAAA;AAE0B;;AAGrC,EAAA,GAAA,CAAA,SAAA,CAAA,YAAA,GAAY,YAAA;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,cAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAAZ;;AAUA,EAAA,GAAA,CAAA,SAAA,CAAA,QAAA,GAAQ,YAAA;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,UAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAAR;;AAYA,EAAA,GAAA,CAAA,SAAA,CAAA,cAAA,GAAc,YAAA;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,gBAAA,EAAA;AAAA,oBAAA;AAAA,KAAA,EAAA,SAAA,CAAA;AAAA,GAAd;;AAYA,EAAA,GAAA,CAAA,SAAA,CAAA,gBAAA,GAAgB,UAAC,KAAD,EAAc;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,kBAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAA9B;;AAYA,EAAA,GAAA,CAAA,SAAA,CAAA,oBAAA,GAAoB,UAAC,KAAD,EAAc;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,sBAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAAlC;;AAaA,EAAA,GAAA,CAAA,SAAA,CAAA,aAAA,GAAa,YAAA;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,eAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAAb;;AAcA,EAAA,GAAA,CAAA,SAAA,CAAA,cAAA,GAAc,YAAA;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,gBAAA,EAAA;AAAA,oBAAA,IAAA;AAAA,sBAAA,CAAA;AAAA,oBAAA;AAAA,KAAA,EAAA,SAAA,CAAA;AAAA,GAAd;;AAUA,EAAA,GAAA,CAAA,SAAA,CAAA,qBAAA,GAAqB,YAAA;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,uBAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAArB;;AAYA,EAAA,GAAA,CAAA,SAAA,CAAA,wBAAA,GAAwB,UAAC,OAAD,EAA2C;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,0BAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAAnE;;AAgBA,EAAA,GAAA,CAAA,SAAA,CAAA,gCAAA,GAAgC,UAAC,aAAD,EAAqC;AAAA,WAAA,OAAA,CAAA,IAAA,EAAA,kCAAA,EAAA,EAAA,EAAA,SAAA,CAAA;AAAA,GAArE;;AAIkD,EAAA,GAAA,CAAA,UAAA,GAAA,KAAA;AAA4B,EAAA,GAAA,CAAA,MAAA,GAAA,2CAAA;AAA8D,EAAA,GAAA,CAAA,SAAA,GAAA,WAAA;AAAiC,EAAA,GAAA,CAAA,IAAA,GAAA,2EAAA;AAA4F,EAAA,GAAA,CAAA,SAAA,GAAA,CAAA,SAAA,EAAA,KAAA,CAAA;;MA1H9P,I,GAAG,SADf,WACe,CADf,CACe,EADf;AAAA,WAAY,gBACG,CAAA,CAAA,IAAA,GAAA,CADf;AACe,G;;;;;;;;;;;;;;;AAAE,G;;AAAC,SAhInB,GAgImB;AAhIjB,CAGF,CA6HyB,iBA7HzB,CAAA;;AA8HC,SADY,GACZ","sourcesContent":["import { Cordova, IonicNativePlugin, Plugin } from '@ionic-native/core';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nexport interface NotificationData {\n  /**\n   * Determines whether the notification was pressed or not\n   */\n\n  wasTapped: boolean;\n\n  /**\n   * Notification data hash item\n   */\n\n  [name: string]: any;\n}\n\nexport interface IRequestPushPermissionIOSOptions {\n  /**\n   * Options exclusive for iOS 9 support\n   */\n  ios9Support?: {\n    /**\n     * How long it will wait for a decision from the user before returning `false`, defaults to 10\n     */\n    timeout?: number;\n    /**\n     * How long between each permission verification, defaults to 0.3\n     */\n    interval?: number;\n  };\n}\n\nexport interface IChannelConfiguration {\n  /**\n   * Channel id, used in the android_channel_id push payload key\n   */\n  id: string;\n  /**\n   * Channel name, visible for the user\n   */\n  name: string;\n  /**\n   * Channel description, visible for the user\n   */\n  description?: string;\n  /**\n   * Importance for notifications of this channel\n   * https://developer.android.com/guide/topics/ui/notifiers/notifications#importance\n   */\n  importance?: 'none' | 'min' | 'low' | 'default' | 'high';\n  /**\n   * Visibility for notifications of this channel\n   * https://developer.android.com/training/notify-user/build-notification#lockscreenNotification\n   */\n  visibility?: 'public' | 'private' | 'secret';\n  /**\n   * Default sound resource for notifications of this channel\n   * The file should located as resources/raw/[resource name].mp3\n   */\n  sound?: string;\n  /**\n   * Enable lights for notifications of this channel\n   */\n  lights?: boolean;\n  /**\n   * Enable vibration for notifications of this channel\n   */\n  vibration?: boolean;\n}\n\n/**\n * @name FCM\n * @capacitorincompatible true\n * @description\n * Provides basic functionality for Firebase Cloud Messaging\n *\n * @usage\n * ```typescript\n * import { FCM } from '@ionic-native/fcm/ngx';\n *\n * constructor(private fcm: FCM) {}\n *\n * ...\n *\n * this.fcm.subscribeToTopic('marketing');\n *\n * this.fcm.getToken().then(token => {\n *   backend.registerToken(token);\n * });\n *\n * this.fcm.onNotification().subscribe(data => {\n *   if(data.wasTapped){\n *     console.log(\"Received in background\");\n *   } else {\n *     console.log(\"Received in foreground\");\n *   };\n * });\n *\n * this.fcm.onTokenRefresh().subscribe(token => {\n *   backend.registerToken(token);\n * });\n *\n * this.fcm.hasPermission().then(hasPermission => {\n *   if (hasPermission) {\n *     console.log(\"Has permission!\");\n *   }\n * })\n *\n * this.fcm.clearAllNotifications();\n *\n * this.fcm.unsubscribeFromTopic('marketing');\n *\n * ```\n * @interfaces\n * NotificationData\n * IRequestPushPermissionIOSOptions\n * IChannelConfiguration\n */\n@Plugin({\n  pluginName: 'FCM',\n  plugin: 'cordova-plugin-fcm-with-dependecy-updated',\n  pluginRef: 'FCMPlugin',\n  repo: 'https://github.com/andrehtissot/cordova-plugin-fcm-with-dependecy-updated',\n  platforms: ['Android', 'iOS'],\n})\n@Injectable()\nexport class FCM extends IonicNativePlugin {\n  /**\n   * Gets ios device's current APNS token\n   *\n   * @returns {Promise<string>} Returns a Promise that resolves with the APNS token\n   */\n  @Cordova()\n  getAPNSToken(): Promise<string> {\n    return;\n  }\n\n  /**\n   * Gets device's current registration id\n   *\n   * @returns {Promise<string>} Returns a Promise that resolves with the registration id token\n   */\n  @Cordova()\n  getToken(): Promise<string> {\n    return;\n  }\n\n  /**\n   * Event firing on the token refresh\n   *\n   * @returns {Observable<string>} Returns an Observable that notifies with the change of device's registration id\n   */\n  @Cordova({\n    observable: true,\n  })\n  onTokenRefresh(): Observable<string> {\n    return;\n  }\n\n  /**\n   * Subscribes you to a [topic](https://firebase.google.com/docs/notifications/android/console-topics)\n   *\n   * @param {string} topic Topic to be subscribed to\n   *\n   * @returns {Promise<any>} Returns a promise resolving in result of subscribing to a topic\n   */\n  @Cordova()\n  subscribeToTopic(topic: string): Promise<any> {\n    return;\n  }\n\n  /**\n   * Unsubscribes you from a [topic](https://firebase.google.com/docs/notifications/android/console-topics)\n   *\n   * @param {string} topic Topic to be unsubscribed from\n   *\n   * @returns {Promise<any>} Returns a promise resolving in result of unsubscribing from a topic\n   */\n  @Cordova()\n  unsubscribeFromTopic(topic: string): Promise<any> {\n    return;\n  }\n\n  /**\n   * Checking for permissions on iOS. On android, it always returns `true`.\n   *\n   * @returns {Promise<boolean | null>} Returns a Promise:\n   * - true: push was allowed (or platform is android)\n   * - false: push will not be available\n   * - null: still not answered, recommended checking again later.\n   */\n  @Cordova()\n  hasPermission(): Promise<boolean | null> {\n    return;\n  }\n\n  /**\n   * Watch for incoming notifications\n   *\n   * @returns {Observable<any>} returns an object with data from the notification\n   */\n  @Cordova({\n    observable: true,\n    successIndex: 0,\n    errorIndex: 2,\n  })\n  onNotification(): Observable<NotificationData> {\n    return;\n  }\n\n  /**\n   * Removes existing push notifications from the notifications center\n   *\n   * @returns {Promise<void>}\n   */\n  @Cordova()\n  clearAllNotifications(): void {\n    return;\n  }\n\n  /**\n   * Request push notification permission, alerting the user if it not have yet decided\n   *\n   * @param {IRequestPushPermissionIOSOptions} options Options for push request\n   *\n   * @returns {Promise<boolean>} Returns a Promise that resolves with the permission status\n   */\n  @Cordova()\n  requestPushPermissionIOS(options?: IRequestPushPermissionIOSOptions): Promise<boolean> {\n    return;\n  }\n\n  /**\n   * For Android, some notification properties are only defined programmatically.\n   *\n   * Channel can define the default behavior for notifications on Android 8.0+.\n   *\n   * Once a channel is created, it stays unchangeable until the user uninstalls the app.\n   *\n   * @param channelConfig\n   *\n   * @returns {Promise<void>}\n   */\n  @Cordova()\n  createNotificationChannelAndroid(channelConfig: IChannelConfiguration): void {\n    return;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}